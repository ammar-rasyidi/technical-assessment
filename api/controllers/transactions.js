import mongoose from 'mongoose';
import Transaction from '../models/Transaction.js';

/**
 * GET /api/transactions
 * ---------------------
 * Retrieve a list of all transactions.
 *
 * Optional Query Parameters:
 * - type: Filter transactions by type. Valid values are "Stake", "Borrow", or "Lend".
 *
 * Success Response:
 * - 200 OK: Returns an array of transactions (filtered if query param is used).
 *
 * Error Response:
 * - 400 Bad Request: Returned if an invalid type value is provided.
 */
export const index = async (req, res) => {
  try {
    const { type, page = 1, limit = 10 } = req.query;
    const validTypes = ['Stake', 'Borrow', 'Lend'];

    // Validate parameters
    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    
    if (isNaN(pageNum) || pageNum < 1) {
      return res.status(400).json({ error: 'Invalid page number' });
    }
    
    if (isNaN(limitNum) || limitNum < 1 || limitNum > 100) {
      return res.status(400).json({ error: 'Invalid limit value (1-100 allowed)' });
    }

    if (type && !validTypes.includes(type)) {
      return res.status(400).json({
        error: 'Invalid transaction type',
        message: `Valid types are: ${validTypes.join(', ')}`
      });
    }

    const query = type ? { transactionType: type } : {};
    const totalCount = await Transaction.countDocuments(query);
    const totalPages = Math.ceil(totalCount / limitNum);
    const skip = (pageNum - 1) * limitNum;
    
    // Get paginated results
    const transactions = await Transaction.find(query)
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limitNum);

    res.status(200).json({
      data: transactions,
      pagination: {
        totalItems: totalCount,
        totalPages,
        currentPage: pageNum,
        itemsPerPage: limitNum,
        hasNextPage: pageNum < totalPages,
        hasPrevPage: pageNum > 1
      }
    });
  } catch (err) {
    res.status(500).json({
      error: 'Server error',
      message: err.message
    });
  }
};

/**
 * POST /api/transactions
 * ----------------------
 * Create a new transaction.
 *
 * Request Body:
 * - transactionType (string): Must be one of "Stake", "Borrow", or "Lend".
 * - token (string): Must be a non-empty string.
 * - amount (number): Must be a positive number.
 * - Note: The 'id' is generated by the backend and should not be included in the request.
 *
 * Success Response:
 * - 201 Created: Returns the newly created transaction object.
 *
 * Error Response:
 * - 400 Bad Request: Returned if validation fails (e.g., invalid type, empty token, or non-positive amount).
 */
export const create = async (req, res) => {
  try {
    const { username, transactionType, token, amount, status, description } = req.body;
    const errors = [];
    const validTypes = ['Stake', 'Borrow', 'Lend'];
    const validStatuses = ['pending', 'completed', 'failed'];

    // Validation
    if (!validTypes.includes(transactionType)) {
      errors.push(`transactionType must be one of: ${validTypes.join(', ')}`);
    }

    if (!token || typeof token !== 'string' || token.trim() === '') {
      errors.push('token must be a non-empty string');
    }

    if (typeof amount !== 'number' || amount <= 0) {
      errors.push('amount must be a positive number');
    }

    if (errors.length > 0) {
      return res.status(400).json({
        error: 'Validation failed',
        details: errors
      });
    }

    if (status && !validStatuses.includes(status)) {
      errors.push(`status must be one of: ${validStatuses.join(', ')}`);
    }

    if (description && typeof description !== 'string') {
      errors.push('description must be a string');
    }

    const newTransaction = new Transaction({
      username,
      transactionType,
      token: token.trim(),
      amount,
      status,
      description
    });

    const savedTransaction = await newTransaction.save();
    res.status(201).json(savedTransaction);
    
  } catch (err) {
    // Handle Mongoose validation errors
    if (err.name === 'ValidationError') {
      const errors = Object.values(err.errors).map(e => e.message);
      return res.status(400).json({
        error: 'Validation failed',
        details: errors
      });
    }
    
    res.status(500).json({
      error: 'Server error',
      message: err.message
    });
  }
};

/**
 * GET /api/transactions/:id
 * -------------------------
 * Retrieve a specific transaction by its ID.
 *
 * URL Parameters:
 * - id: The unique identifier of the transaction to retrieve.
 *
 * Success Response:
 * - 200 OK: Returns the transaction object.
 *
 * Error Response:
 * - 404 Not Found: Returned if no transaction exists with the given ID.
 */
export const fetchById = async (req, res) => {
  try {
    if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
      return res.status(400).json({
        error: 'Invalid ID format',
        message: 'The provided ID is not valid'
      });
    }

    const transaction = await Transaction.findById(req.params.id);

    if (!transaction) {
      return res.status(404).json({
        error: 'Not found',
        message: `Transaction with ID ${req.params.id} not found`
      });
    }

    res.status(200).json(transaction);
  } catch (err) {
    res.status(500).json({
      error: 'Server error',
      message: err.message
    });
  }
};

/**
 * PATCH /api/transactions/:id
 * ----------------------------
 * Update a specific transaction by its ID (partial update).
 * 
 * URL Parameters:
 * - id: The unique identifier of the transaction to update.
 * 
 * Request Body:
 * - Can include any subset of transaction fields to update:
 *   transactionType, token, amount, status, description, etc.
 * 
 * Validation Rules:
 * - transactionType must be one of "Stake", "Borrow", or "Lend" if provided
 * - token must be a non-empty string if provided
 * - amount must be a positive number if provided
 * 
 * Success Response:
 * - 200 OK: Returns the updated transaction object.
 * 
 * Error Responses:
 * - 400 Bad Request: Invalid ID format or validation error
 * - 404 Not Found: Transaction not found
 */
export const update = async (req, res) => {
  try {
    // Validate ID format
    if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
      return res.status(400).json({
        error: 'Invalid ID format',
        message: 'The provided ID is not valid'
      });
    }

    const { username, transactionType, token, amount, status, description } = req.body;
    const validTypes = ['Stake', 'Borrow', 'Lend'];
    const validStatuses = ['pending', 'completed', 'failed'];
    const errors = [];

    // Validation
    if (username && (typeof username !== 'string' || username.trim() === '')) {
      errors.push('username must be a non-empty string');
    }

    if (transactionType && !validTypes.includes(transactionType)) {
      errors.push(`transactionType must be one of: ${validTypes.join(', ')}`);
    }

    if (token && (typeof token !== 'string' || token.trim() === '')) {
      errors.push('token must be a non-empty string');
    }

    if (amount && (typeof amount !== 'number' || amount <= 0)) {
      errors.push('amount must be a positive number');
    }

    if (status && !validStatuses.includes(status)) {
      errors.push(`status must be one of: ${validStatuses.join(', ')}`);
    }

    if (description && typeof description !== 'string') {
      errors.push('description must be a string');
    }

    // Return validation errors if any
    if (errors.length > 0) {
      return res.status(400).json({
        error: 'Validation failed',
        details: errors
      });
    }

    // Prepare update data
    const updateData = { ...req.body };
    if (token) updateData.token = token.trim();

    // Find and update transaction
    const updatedTransaction = await Transaction.findByIdAndUpdate(
      req.params.id,
      updateData,
      { new: true, runValidators: true }
    );

    // Handle not found
    if (!updatedTransaction) {
      return res.status(404).json({
        error: 'Not found',
        message: `Transaction with ID ${req.params.id} not found`
      });
    }

    res.status(200).json(updatedTransaction);
  } catch (err) {
    // Handle Mongoose validation errors
    if (err.name === 'ValidationError') {
      const errors = Object.values(err.errors).map(e => e.message);
      return res.status(400).json({
        error: 'Validation failed',
        details: errors
      });
    }
    
    res.status(500).json({
      error: 'Server error',
      message: err.message
    });
  }
};


/**
 * DELETE /api/transactions/:id
 * ----------------------------
 * Delete a specific transaction by its ID.
 * 
 * URL Parameters:
 * - id: The unique identifier of the transaction to delete.
 * 
 * Success Response:
 * - 204 No Content: Returns empty body on successful deletion.
 * 
 * Error Responses:
 * - 400 Bad Request: Invalid ID format
 * - 404 Not Found: Transaction not found
 */
export const remove = async (req, res) => {
  try {
    // Validate ID format
    if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
      return res.status(400).json({
        error: 'Invalid ID format',
        message: 'The provided ID is not valid'
      });
    }

    const deletedTransaction = await Transaction.findByIdAndDelete(req.params.id);

    // Handle not found
    if (!deletedTransaction) {
      return res.status(404).json({
        error: 'Not found',
        message: `Transaction with ID ${req.params.id} not found`
      });
    }

    res.status(204).send();
  } catch (err) {
    res.status(500).json({
      error: 'Server error',
      message: err.message
    });
  }
};